#!/bin/bash
#
#       /etc/rc.d/init.d/eosapmond
#
# Starts xrootd 
#
# chkconfig: 345 95 5
# description: Starts apmon to monitor xrootd on EOS
# processname: ApMon

# Source function library.
XRDLOCATION="/opt/eos/"
XRDCONFIG="/etc/xrd.cf.fst"
XRDLOGDIR="/var/log/xroot/"
XRDROLE="fst"
XRDUSER="daemon"
. /etc/init.d/functions
test -e /etc/sysconfig/xrd && . /etc/sysconfig/xrd




mkdir -p ${XRDLOGDIR}/${XRDROLE}
chown -R $XRDUSER ${XRDLOGDIR}

prog="eos_apmond"

if test ! -x ${XRDLOCATION}/bin/$prog ; then
  echo Error: ${XRDLOCATION}/bin/$prog does not exist
  exit 0
fi



RETVAL=0

#
#       See how we were called.
#


host_Group=${HOSTGROUP:-eosatlas}

newline="
"
host=`hostname -f`
xrdpid=`pgrep -u ${XRDUSER} xrootd | tail -1`
cmspid=`pgrep -u ${XRDUSER} cmsd | tail -1`

if [ $xrdpid="" ]; then
    xrdpid=999999
fi

if [ $cmspid="" ]; then
    cmspid=999999
fi
    

srvMonCmds="\$apm->addJobToMonitor($xrdpid, '', 'xrootd_Services', '$host'); "

MONALISA_HOST=${MONALISAHOST:-"lxbra0301.cern.ch"}
APMON_DEBUG_LEVEL=${APMON_DEBUG_LEVEL:-"WARNING"}
destination=${APMON_CONFIG:-"['$MONALISA_HOST']"}
now=`date`
exe="use strict;
use warnings;
use ApMon;
my \$apm = new ApMon(0);
print \"$now\\n\";
select STDOUT; \$| = 1;
select STDERR; \$| = 1;
\$apm->setLogLevel('$APMON_DEBUG_LEVEL');
\$apm->setDestinations($destination);
\$apm->setMonitorClusterNode('${host_Group}_Nodes', '$host');
$srvMonCmds

while(1){
  \$apm->sendBgMonitoring();
  sleep(120);
}
"

 
EOSAPMONSTARTUPFILE="/tmp/.$prog.startup.pl" 
echo $exe > ${EOSAPMONSTARTUPFILE}

# if we are a manager we start the namespace monitor

start() {
        # Check if eosapmond is already running
        avoid=$$;
        if [ ! `pgrep -f -u ${XRDUSER} $prog `  ]; then
            echo -n "Starting $prog: "
            daemon --user ${XRDUSER} "test -e /etc/sysconfig/xrd && source /etc/sysconfig/xrd; cd ${XRDCOREDIR}; ulimit -c unlimited; export PERL5LIB=${XRDLOCATION}/perl/ApMon; ${XRDLOCATION}/bin/$prog ${EOSAPMONSTARTUPFILE} ${XRDLOGDIR}/${XRDROLE}/eosapmonlog >& /dev/null < /dev/null" 
            RETVAL=$?
	    [ $RETVAL -eq 0 ] && touch /var/lock/subsys/$prog
            echo
	else 
            echo $prog already running.  
            echo Stop it first with 'service $prog stop'
            echo and try again or use directly 'service $prog restart'.
            RETVAL=1
        fi
        return $RETVAL
}

stop() {
        echo -n "Stopping $prog: "
        killproc /${XRDLOCATION}/bin/$prog
        RETVAL=$?
        [ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/$prog
        echo
        return $RETVAL
}


restart() {
        stop
        start
}       

reload() {
        restart
}       

status_at() {
    pid=`pidofproc $prog`
    if [ -n "$pid" ]; then
	echo $"$prog (pid $pid) is running..."
    else
	if [ -f /var/lock/subsys/$prog ]; then
	    echo $"$prog dead but subsys locked"
	else
	    echo $"$prog is stopped"
	fi
	RETVAL=1
    fi
    return $RETVAL
}


case "$1" in
start)
        start
        ;;
stop)
        stop
        ;;
reload|restart)
        restart
        ;;
condrestart)
        if [ -f /var/lock/subsys/eosapmon ]; then
            restart
        fi
        ;;
status)
        status_at
        ;;
*)
        echo $"Usage: $0 {start|stop|restart|condrestart|status}"
        exit 1
esac

exit $?
exit $RETVAL
